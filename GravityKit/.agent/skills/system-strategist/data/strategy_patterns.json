{
    "tradeoffs": {
        "sql_vs_nosql": {
            "context": "Choosing primary database",
            "options": [
                {
                    "name": "SQL (Relational)",
                    "pros": [
                        "ACID compliance",
                        "Standardized query language",
                        "Rich join capabilities"
                    ],
                    "cons": [
                        "Harder to scale horizontally",
                        "Rigid schema"
                    ],
                    "best_for": "Financial systems, ERP, CRM"
                },
                {
                    "name": "NoSQL (Document/Key-Value)",
                    "pros": [
                        "Flexible schema",
                        "Easy horizontal scaling",
                        "High write throughput"
                    ],
                    "cons": [
                        "Eventual consistency",
                        "Limited join capabilities"
                    ],
                    "best_for": "Content management, Real-time feeds, IoT"
                }
            ],
            "decision_matrix": "If data is structured and consistency is critical -> SQL. If data is unstructured and speed/scale is priority -> NoSQL."
        },
        "monolith_vs_microservices": {
            "context": "System Architecture Style",
            "options": [
                {
                    "name": "Monolith",
                    "pros": [
                        "Simple to deploy",
                        "Easy debugging",
                        "Low latency (in-memory calls)"
                    ],
                    "cons": [
                        "Hard to scale parts independently",
                        "Tight coupling",
                        "Technology lock-in"
                    ],
                    "best_for": "Startups, MVP, Small-Medium teams"
                },
                {
                    "name": "Microservices",
                    "pros": [
                        "Independent scaling",
                        "Tech stack flexibility",
                        "Fault isolation"
                    ],
                    "cons": [
                        "Complex operations (DevOps)",
                        "Network latency",
                        "Distributed data consistency issues"
                    ],
                    "best_for": "Large enterprises, High scale, multiple independent teams"
                }
            ],
            "decision_matrix": "Start with Monolith. Break into Microservices only when team size > 10 or specific components need independent scaling."
        },
        "rest_vs_graphql": {
            "context": "API Style",
            "options": [
                {
                    "name": "REST",
                    "pros": [
                        "Standard caching",
                        "Simple tooling",
                        "Resource-oriented"
                    ],
                    "cons": [
                        "Over-fetching/Under-fetching",
                        "Multiple round-trips"
                    ],
                    "best_for": "Public APIs, Simple CRUD, Caching-heavy apps"
                },
                {
                    "name": "GraphQL",
                    "pros": [
                        "Exact data fetching",
                        "Single endpoint",
                        "Strongly typed"
                    ],
                    "cons": [
                        "Complex caching",
                        "N+1 query performance risks",
                        "Learning curve"
                    ],
                    "best_for": "Complex UI data requirements, Mobile apps, Aggregating multiple sources"
                }
            ],
            "decision_matrix": "Use REST for simplicity and public APIs. Use GraphQL for complex, data-rich frontends."
        }
    },
    "scalability_plans": {
        "10k_users": {
            "focus": "Vertical Scaling & Basics",
            "strategies": [
                "Optimize Database Indexes (Low hanging fruit)",
                "Upgrade Server Specs (Vertical Scaling)",
                "Implement basic CDN for static assets",
                "Use a managed database service (RDS/Supabase)"
            ]
        },
        "100k_users": {
            "focus": "Horizontal Scaling & Caching",
            "strategies": [
                "Add Read Replicas for Database",
                "Implement Redis/Memcached for hot data",
                "Load Balancer (Nginx/AWS ALB) with multiple App Servers",
                "Asynchronous processing (Worker Queues) for heavy tasks"
            ]
        },
        "1m_users": {
            "focus": "Sharding & Distribution",
            "strategies": [
                "Database Sharding (Horizontal Partitioning)",
                "Multi-region deployment (Geo-DNS)",
                "Event-driven Architecture (Kafka/RabbitMQ)",
                "Circuit Breakers & Rate Limiting"
            ]
        }
    },
    "migration_strategies": {
        "strangler_fig": {
            "name": "Strangler Fig Pattern",
            "description": "Gradually replace specific functionalities of the legacy system with new applications and services.",
            "steps": [
                "Identify edge functionality to carve out.",
                "Build new microservice for that functionality.",
                "Route traffic to new service via proxy.",
                "Repeat until legacy system is strangled."
            ],
            "pros": "Low risk, incremental value.",
            "cons": "Complexity of managing two systems."
        },
        "blue_green": {
            "name": "Blue-Green Deployment",
            "description": "Two identical environments. Blue is live. Deploy to Green. Switch router to Green.",
            "steps": [
                "Deploy new version to Green environment.",
                "Run smoke tests on Green.",
                "Switch Load Balancer to point to Green.",
                "Monitor for errors. Rollback to Blue if needed."
            ],
            "pros": "Zero downtime, instant rollback.",
            "cons": "Double infrastructure cost."
        },
        "canary": {
            "name": "Canary Release",
            "description": "Roll out to a small subset of users (e.g. 5%) before full rollout.",
            "steps": [
                "Deploy to Canary instance.",
                "Route 5% of traffic to Canary.",
                "Monitor metrics (Error rate, Latency).",
                "Gradually increase traffic (10%, 25%, 50%, 100%)."
            ],
            "pros": "Limits blast radius of bugs.",
            "cons": "Complex routing & monitoring setup."
        }
    }
}